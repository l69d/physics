<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Projectile Motion Physics Simulation</title>
<style>
  body {
    margin: 0;
    padding: 20px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f5f5f5;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
  }
  
  #container {
    max-width: 800px;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }
  
  h1 {
    text-align: center;
    color: #333;
    margin-top: 0;
    font-size: 24px;
  }
  
  #controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
  }
  
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  
  .control-group label {
    font-size: 12px;
    color: #666;
    font-weight: 600;
  }
  
  input[type="range"] {
    width: 100%;
  }
  
  .slider-value {
    font-size: 14px;
    color: #333;
    font-weight: bold;
  }
  
  button {
    padding: 10px 20px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
  }
  
  button:hover {
    background: #0056b3;
  }
  
  button:disabled {
    background: #6c757d;
    cursor: not-allowed;
  }
  
  #pauseBtn {
    background: #28a745;
  }
  
  #pauseBtn:hover {
    background: #218838;
  }
  
  #pauseBtn.paused {
    background: #ffc107;
  }
  
  #pauseBtn.paused:hover {
    background: #e0a800;
  }
  
  .button-group {
    display: flex;
    gap: 10px;
    grid-column: 1 / -1;
    justify-content: center;
  }
  
  canvas {
    display: block;
    border: 1px solid #ddd;
    margin: 0 auto 10px;
    background: #fafafa;
  }
  
  #readouts {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 10px;
    padding: 15px;
    background: #f8f9fa;
    border-radius: 4px;
    margin-top: 10px;
  }
  
  .readout {
    text-align: center;
  }
  
  .readout-label {
    font-size: 11px;
    color: #666;
    font-weight: 600;
    text-transform: uppercase;
  }
  
  .readout-value {
    font-size: 16px;
    color: #333;
    font-weight: bold;
    margin-top: 5px;
  }
  
  .graph-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: 15px;
  }
  
  .graph-item {
    display: flex;
    flex-direction: column;
  }
  
  .graph-label {
    text-align: center;
    font-size: 12px;
    color: #666;
    font-weight: 600;
    margin: 5px 0;
  }
</style>
</head>
<body>
<div id="container">
  <h1>Projectile Motion Physics Simulation</h1>
  
  <div id="controls">
    <div class="control-group">
      <label>Initial Height (m)</label>
      <input type="range" id="heightSlider" min="0" max="50" value="20" step="1">
      <span class="slider-value" id="heightValue">20.0 m</span>
    </div>
    
    <div class="control-group">
      <label>Launch Speed (m/s)</label>
      <input type="range" id="speedSlider" min="0" max="50" value="20" step="1">
      <span class="slider-value" id="speedValue">20.0 m/s</span>
    </div>
    
    <div class="control-group">
      <label>Launch Angle (°)</label>
      <input type="range" id="angleSlider" min="0" max="90" value="45" step="1">
      <span class="slider-value" id="angleValue">45°</span>
    </div>
    
    <div class="button-group">
      <button id="resetBtn">Reset/Start</button>
      <button id="pauseBtn" disabled>Pause</button>
    </div>
  </div>
  
  <canvas id="animationCanvas" width="700" height="400"></canvas>
  
  <div id="readouts">
    <div class="readout">
      <div class="readout-label">Time (s)</div>
      <div class="readout-value" id="timeReadout">0.00</div>
    </div>
    <div class="readout">
      <div class="readout-label">X Position (m)</div>
      <div class="readout-value" id="posXReadout">0.00</div>
    </div>
    <div class="readout">
      <div class="readout-label">Y Position (m)</div>
      <div class="readout-value" id="posYReadout">0.00</div>
    </div>
    <div class="readout">
      <div class="readout-label">Vx (m/s)</div>
      <div class="readout-value" id="velXReadout">0.00</div>
    </div>
    <div class="readout">
      <div class="readout-label">Vy (m/s)</div>
      <div class="readout-value" id="velYReadout">0.00</div>
    </div>
    <div class="readout">
      <div class="readout-label">Speed (m/s)</div>
      <div class="readout-value" id="speedReadout">0.00</div>
    </div>
  </div>
  
  <div class="graph-container">
    <div class="graph-item">
      <div class="graph-label">X Position vs Time</div>
      <canvas id="graphX" width="340" height="120"></canvas>
    </div>
    
    <div class="graph-item">
      <div class="graph-label">Y Position vs Time</div>
      <canvas id="graphY" width="340" height="120"></canvas>
    </div>
    
    <div class="graph-item">
      <div class="graph-label">X Velocity vs Time</div>
      <canvas id="graphVx" width="340" height="120"></canvas>
    </div>
    
    <div class="graph-item">
      <div class="graph-label">Y Velocity vs Time</div>
      <canvas id="graphVy" width="340" height="120"></canvas>
    </div>
  </div>
</div>

<script>
// Constants
const G = 9.81; // m/s² (gravitational acceleration)
const BALL_RADIUS = 8; // pixels
const GRAPH_TIME_WINDOW = 5; // seconds visible in graphs
const FPS = 60;
const CANVAS_MARGIN = 50; // pixels margin for visibility
const VELOCITY_ARROW_SCALE = 3; // Scale factor for velocity vector display

// Canvas elements
const animCanvas = document.getElementById('animationCanvas');
const animCtx = animCanvas.getContext('2d');
const graphXCanvas = document.getElementById('graphX');
const graphXCtx = graphXCanvas.getContext('2d');
const graphYCanvas = document.getElementById('graphY');
const graphYCtx = graphYCanvas.getContext('2d');
const graphVxCanvas = document.getElementById('graphVx');
const graphVxCtx = graphVxCanvas.getContext('2d');
const graphVyCanvas = document.getElementById('graphVy');
const graphVyCtx = graphVyCanvas.getContext('2d');

// Control elements
const heightSlider = document.getElementById('heightSlider');
const speedSlider = document.getElementById('speedSlider');
const angleSlider = document.getElementById('angleSlider');
const heightValue = document.getElementById('heightValue');
const speedValue = document.getElementById('speedValue');
const angleValue = document.getElementById('angleValue');
const resetBtn = document.getElementById('resetBtn');
const pauseBtn = document.getElementById('pauseBtn');

// Readout elements
const timeReadout = document.getElementById('timeReadout');
const posXReadout = document.getElementById('posXReadout');
const posYReadout = document.getElementById('posYReadout');
const velXReadout = document.getElementById('velXReadout');
const velYReadout = document.getElementById('velYReadout');
const speedReadout = document.getElementById('speedReadout');

// Simulation state
let h0 = 20; // initial height (m)
let v0 = 20; // launch speed (m/s)
let angle = 45; // launch angle (degrees)
let vx0 = 0; // initial x velocity component
let vy0 = 0; // initial y velocity component
let startTime = null;
let pausedTime = 0;
let pauseStartTime = null;
let isRunning = false;
let isPaused = false;
let animationId = null;
let maxHeight = 0;
let maxRange = 0;

// Trail history for projectile path
let trailPoints = [];

// Data history for graphs
let dataHistory = {
  time: [],
  posX: [],
  posY: [],
  velX: [],
  velY: []
};

// Update slider displays
heightSlider.addEventListener('input', () => {
  heightValue.textContent = parseFloat(heightSlider.value).toFixed(1) + ' m';
});

speedSlider.addEventListener('input', () => {
  speedValue.textContent = parseFloat(speedSlider.value).toFixed(1) + ' m/s';
});

angleSlider.addEventListener('input', () => {
  angleValue.textContent = parseInt(angleSlider.value) + '°';
});

// Reset button handler
resetBtn.addEventListener('click', () => {
  h0 = parseFloat(heightSlider.value);
  v0 = parseFloat(speedSlider.value);
  angle = parseFloat(angleSlider.value);
  
  // Calculate velocity components
  const angleRad = angle * Math.PI / 180;
  vx0 = v0 * Math.cos(angleRad);
  vy0 = v0 * Math.sin(angleRad);
  
  resetSimulation();
});

// Pause button handler
pauseBtn.addEventListener('click', () => {
  if (isPaused) {
    isPaused = false;
    pausedTime += performance.now() - pauseStartTime;
    pauseBtn.textContent = 'Pause';
    pauseBtn.classList.remove('paused');
    animationId = requestAnimationFrame(animate);
  } else {
    isPaused = true;
    pauseStartTime = performance.now();
    pauseBtn.textContent = 'Resume';
    pauseBtn.classList.add('paused');
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
  }
});

// Reset simulation
function resetSimulation() {
  if (animationId) {
    cancelAnimationFrame(animationId);
  }
  
  startTime = null;
  pausedTime = 0;
  pauseStartTime = null;
  isRunning = true;
  isPaused = false;
  maxHeight = h0;
  maxRange = 0;
  trailPoints = [];
  
  dataHistory = {
    time: [],
    posX: [],
    posY: [],
    velX: [],
    velY: []
  };
  
  // Disable sliders during simulation
  heightSlider.disabled = true;
  speedSlider.disabled = true;
  angleSlider.disabled = true;
  pauseBtn.disabled = false;
  pauseBtn.textContent = 'Pause';
  pauseBtn.classList.remove('paused');
  
  // Clear canvases
  clearCanvas(animCtx, animCanvas.width, animCanvas.height);
  clearCanvas(graphXCtx, graphXCanvas.width, graphXCanvas.height);
  clearCanvas(graphYCtx, graphYCanvas.width, graphYCanvas.height);
  clearCanvas(graphVxCtx, graphVxCanvas.width, graphVxCanvas.height);
  clearCanvas(graphVyCtx, graphVyCanvas.width, graphVyCanvas.height);
  
  // Start animation
  animationId = requestAnimationFrame(animate);
}

// Main animation loop
function animate(timestamp) {
  if (!startTime) startTime = timestamp - pausedTime;
  const t = (timestamp - startTime - pausedTime) / 1000; // time in seconds
  
  // Physics calculations (projectile motion)
  const x = vx0 * t; // horizontal position
  const y = h0 + vy0 * t - 0.5 * G * t * t; // vertical position
  const vx = vx0; // horizontal velocity (constant)
  const vy = vy0 - G * t; // vertical velocity
  const speed = Math.sqrt(vx * vx + vy * vy); // total speed
  
  // Track maximum values for dynamic scaling
  if (y > maxHeight) maxHeight = y;
  if (x > maxRange) maxRange = x;
  
  // Add to trail
  if (trailPoints.length === 0 || t - trailPoints[trailPoints.length - 1].t > 0.05) {
    trailPoints.push({x, y, t});
  }
  
  // Check if projectile has hit ground (y <= 0)
  if (y <= 0 && t > 0) {
    isRunning = false;
    isPaused = false;
    heightSlider.disabled = false;
    speedSlider.disabled = false;
    angleSlider.disabled = false;
    pauseBtn.disabled = true;
    
    // Record final state at ground level
    const finalT = t - (y / vy); // Interpolate exact landing time
    const finalX = vx0 * finalT;
    recordData(finalT, finalX, 0, vx, vy0 - G * finalT);
    
    // Draw final frame
    drawAnimation(finalX, 0, vx, vy0 - G * finalT);
    updateReadouts(finalT, finalX, 0, vx, vy0 - G * finalT, speed);
    drawGraphs(finalT);
    
    return;
  }
  
  // Record data
  recordData(t, x, y, vx, vy);
  
  // Draw animation
  drawAnimation(x, y, vx, vy);
  
  // Update readouts
  updateReadouts(t, x, y, vx, vy, speed);
  
  // Draw graphs
  drawGraphs(t);
  
  // Continue animation
  if (isRunning && !isPaused) {
    animationId = requestAnimationFrame(animate);
  }
}

// Record data point
function recordData(t, x, y, vx, vy) {
  dataHistory.time.push(t);
  dataHistory.posX.push(x);
  dataHistory.posY.push(y);
  dataHistory.velX.push(vx);
  dataHistory.velY.push(vy);
}

// Draw animation canvas with dynamic scaling
function drawAnimation(x, y, vx, vy) {
  clearCanvas(animCtx, animCanvas.width, animCanvas.height);
  
  // Calculate dynamic viewport
  const viewportXMax = Math.max(maxRange * 1.1, 20);
  const viewportYMax = Math.max(maxHeight * 1.2, 20);
  const viewportXMin = -5;
  const viewportYMin = 0;
  
  const scaleX = (animCanvas.width - 2 * CANVAS_MARGIN) / (viewportXMax - viewportXMin);
  const scaleY = (animCanvas.height - 2 * CANVAS_MARGIN) / (viewportYMax - viewportYMin);
  const scale = Math.min(scaleX, scaleY);
  
  // Helper functions to convert meters to canvas pixels
  function xToPixels(xMeters) {
    return CANVAS_MARGIN + (xMeters - viewportXMin) * scale;
  }
  
  function yToPixels(yMeters) {
    return animCanvas.height - CANVAS_MARGIN - (yMeters - viewportYMin) * scale;
  }
  
  // Draw grid lines
  const gridSpacingX = calculateGridSpacing(viewportXMax - viewportXMin);
  const gridSpacingY = calculateGridSpacing(viewportYMax - viewportYMin);
  
  animCtx.strokeStyle = '#e0e0e0';
  animCtx.lineWidth = 1;
  animCtx.fillStyle = '#999';
  animCtx.font = '10px sans-serif';
  
  // Vertical grid lines (x-axis)
  for (let gx = 0; gx <= viewportXMax; gx += gridSpacingX) {
    const px = xToPixels(gx);
    animCtx.beginPath();
    animCtx.moveTo(px, CANVAS_MARGIN / 2);
    animCtx.lineTo(px, animCanvas.height - CANVAS_MARGIN);
    animCtx.stroke();
    animCtx.fillText(gx.toFixed(0) + 'm', px - 10, animCanvas.height - CANVAS_MARGIN + 15);
  }
  
  // Horizontal grid lines (y-axis)
  for (let gy = 0; gy <= viewportYMax; gy += gridSpacingY) {
    const py = yToPixels(gy);
    animCtx.beginPath();
    animCtx.moveTo(CANVAS_MARGIN, py);
    animCtx.lineTo(animCanvas.width - CANVAS_MARGIN / 2, py);
    animCtx.stroke();
    animCtx.fillText(gy.toFixed(0) + 'm', 5, py + 3);
  }
  
  // Draw ground line (y = 0)
  const groundY = yToPixels(0);
  animCtx.strokeStyle = '#333';
  animCtx.lineWidth = 3;
  animCtx.beginPath();
  animCtx.moveTo(CANVAS_MARGIN, groundY);
  animCtx.lineTo(animCanvas.width - CANVAS_MARGIN / 2, groundY);
  animCtx.stroke();
  
  // Draw launch point
  const launchX = xToPixels(0);
  const launchY = yToPixels(h0);
  animCtx.fillStyle = '#666';
  animCtx.beginPath();
  animCtx.arc(launchX, launchY, 4, 0, 2 * Math.PI);
  animCtx.fill();
  
  // Draw trajectory trail
  animCtx.strokeStyle = 'rgba(0, 123, 255, 0.3)';
  animCtx.lineWidth = 2;
  animCtx.beginPath();
  for (let i = 0; i < trailPoints.length; i++) {
    const px = xToPixels(trailPoints[i].x);
    const py = yToPixels(trailPoints[i].y);
    if (i === 0) {
      animCtx.moveTo(px, py);
    } else {
      animCtx.lineTo(px, py);
    }
  }
  animCtx.stroke();
  
  // Draw ball
  const ballX = xToPixels(x);
  const ballY = yToPixels(y);
  animCtx.fillStyle = '#ff4444';
  animCtx.strokeStyle = '#cc0000';
  animCtx.lineWidth = 2;
  animCtx.beginPath();
  animCtx.arc(ballX, ballY, BALL_RADIUS, 0, 2 * Math.PI);
  animCtx.fill();
  animCtx.stroke();
  
  // Draw velocity vector
  const speed = Math.sqrt(vx * vx + vy * vy);
  if (speed > 0.1) {
    const arrowLength = speed * VELOCITY_ARROW_SCALE;
    const arrowEndX = ballX + (vx / speed) * arrowLength;
    const arrowEndY = ballY - (vy / speed) * arrowLength; // Negative because canvas y is inverted
    
    // Draw arrow line
    animCtx.strokeStyle = '#00aa00';
    animCtx.lineWidth = 2;
    animCtx.beginPath();
    animCtx.moveTo(ballX, ballY);
    animCtx.lineTo(arrowEndX, arrowEndY);
    animCtx.stroke();
    
    // Draw arrowhead
    const headLength = 8;
    const angle = Math.atan2(ballY - arrowEndY, arrowEndX - ballX);
    animCtx.fillStyle = '#00aa00';
    animCtx.beginPath();
    animCtx.moveTo(arrowEndX, arrowEndY);
    animCtx.lineTo(
      arrowEndX - headLength * Math.cos(angle - Math.PI / 6),
      arrowEndY + headLength * Math.sin(angle - Math.PI / 6)
    );
    animCtx.lineTo(
      arrowEndX - headLength * Math.cos(angle + Math.PI / 6),
      arrowEndY + headLength * Math.sin(angle + Math.PI / 6)
    );
    animCtx.closePath();
    animCtx.fill();
    
    // Draw velocity label
    animCtx.fillStyle = '#00aa00';
    animCtx.font = 'bold 11px sans-serif';
    animCtx.fillText('v=' + speed.toFixed(1) + ' m/s', arrowEndX + 5, arrowEndY - 5);
  }
  
  // Draw position indicator
  animCtx.fillStyle = '#333';
  animCtx.font = 'bold 11px sans-serif';
  animCtx.fillText('(' + x.toFixed(1) + ', ' + y.toFixed(1) + ')', ballX + 15, ballY - 15);
}

// Calculate appropriate grid spacing
function calculateGridSpacing(range) {
  const targetGridLines = 6;
  const rawSpacing = range / targetGridLines;
  const magnitude = Math.pow(10, Math.floor(Math.log10(rawSpacing)));
  const normalized = rawSpacing / magnitude;
  
  if (normalized < 1.5) return magnitude;
  if (normalized < 3.5) return 2 * magnitude;
  if (normalized < 7.5) return 5 * magnitude;
  return 10 * magnitude;
}

// Update numeric readouts
function updateReadouts(t, x, y, vx, vy, speed) {
  timeReadout.textContent = t.toFixed(2);
  posXReadout.textContent = x.toFixed(2);
  posYReadout.textContent = y.toFixed(2);
  velXReadout.textContent = vx.toFixed(2);
  velYReadout.textContent = vy.toFixed(2);
  speedReadout.textContent = speed.toFixed(2);
}

// Draw all graphs
function drawGraphs(currentTime) {
  drawGraph(graphXCtx, graphXCanvas, dataHistory.time, dataHistory.posX, currentTime, 'X (m)');
  drawGraph(graphYCtx, graphYCanvas, dataHistory.time, dataHistory.posY, currentTime, 'Y (m)');
  drawGraph(graphVxCtx, graphVxCanvas, dataHistory.time, dataHistory.velX, currentTime, 'Vx (m/s)');
  drawGraph(graphVyCtx, graphVyCanvas, dataHistory.time, dataHistory.velY, currentTime, 'Vy (m/s)');
}

// Generic graph drawing function
function drawGraph(ctx, canvas, times, values, currentTime, label) {
  clearCanvas(ctx, canvas.width, canvas.height);
  
  if (times.length === 0) return;
  
  const timeMax = Math.max(currentTime, GRAPH_TIME_WINDOW);
  const timeMin = Math.max(0, timeMax - GRAPH_TIME_WINDOW);
  
  const indices = times.map((t, i) => t >= timeMin && t <= timeMax ? i : -1).filter(i => i >= 0);
  if (indices.length === 0) return;
  
  const visibleTimes = indices.map(i => times[i]);
  const visibleValues = indices.map(i => values[i]);
  
  const valueMin = Math.min(...visibleValues);
  const valueMax = Math.max(...visibleValues);
  const valueRange = valueMax - valueMin;
  const valuePadding = valueRange * 0.1 || 1;
  const plotMin = valueMin - valuePadding;
  const plotMax = valueMax + valuePadding;
  const plotRange = plotMax - plotMin;
  
  // Draw grid
  ctx.strokeStyle = '#e8e8e8';
  ctx.lineWidth = 1;
  ctx.fillStyle = '#999';
  ctx.font = '9px sans-serif';
  
  const numHGridLines = 4;
  for (let i = 0; i <= numHGridLines; i++) {
    const value = plotMin + (plotRange * i / numHGridLines);
    const y = canvas.height - 15 - ((value - plotMin) / plotRange) * (canvas.height - 25);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
    ctx.fillText(value.toFixed(1), 2, y - 2);
  }
  
  // Draw axes
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height - 15);
  ctx.lineTo(canvas.width, canvas.height - 15);
  ctx.stroke();
  
  // Draw data line
  ctx.strokeStyle = '#007bff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  
  for (let i = 0; i < visibleTimes.length; i++) {
    const x = ((visibleTimes[i] - timeMin) / GRAPH_TIME_WINDOW) * canvas.width;
    const y = canvas.height - 15 - ((visibleValues[i] - plotMin) / plotRange) * (canvas.height - 25);
    
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  }
  ctx.stroke();
  
  // Draw "now" line
  const nowX = ((currentTime - timeMin) / GRAPH_TIME_WINDOW) * canvas.width;
  ctx.strokeStyle = '#ff4444';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(nowX, 0);
  ctx.lineTo(nowX, canvas.height - 15);
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw time labels
  ctx.fillStyle = '#666';
  ctx.font = '9px sans-serif';
  ctx.fillText(timeMin.toFixed(1) + 's', 2, canvas.height - 3);
  ctx.fillText(timeMax.toFixed(1) + 's', canvas.width - 30, canvas.height - 3);
}

// Helper function to clear canvas
function clearCanvas(ctx, width, height) {
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#fafafa';
  ctx.fillRect(0, 0, width, height);
}

// Initialize display
const angleRad = angle * Math.PI / 180;
vx0 = v0 * Math.cos(angleRad);
vy0 = v0 * Math.sin(angleRad);

heightValue.textContent = h0.toFixed(1) + ' m';
speedValue.textContent = v0.toFixed(1) + ' m/s';
angleValue.textContent = angle + '°';

drawAnimation(0, h0, vx0, vy0);
updateReadouts(0, 0, h0, vx0, vy0, v0);
</script>
</body>
</html>